import lingo/pegcode/driver;


Program (d : Declarations, b : Block) ;
Declarations(decls : [VarDecl]) ;
Block(stmts : [Statement]) ;
UndetermChoice(blocks : [Block]) ; 
UndetermIteration(block : Block) ; 

ArExpr ::= ArSum, ArMult, ArSub, ArDiv, ArInt, ArrInt, ArMod, Identifier;
	ArSum(lhs : ArExpr, rhs : ArExpr);
	ArMult(lhs : ArExpr, rhs : ArExpr);
	ArSub(lhs : ArExpr, rhs : ArExpr);
	ArDiv(lhs : ArExpr, rhs : ArExpr);
	ArMod(lhs : ArExpr, rhs : ArExpr);
	ArInt(x : int);
	ArrInt(arr: [ArInt]);
	Identifier(id : string);


Statement ::= VarAssign, Test;
	VarAssign(id : Identifier, expr : ArExpr);
	Test(expr : ArExpr);

VarDecl(id : Identifier, type : Type);

Type(t : string);



block2s (b : Block) -> string {
	switch (b : Block) {
		Block(stmts): {
			"Block(" + stmts2s(stmts) + ")"
		}
	}
}

stmts2s (stmts : [Statement]) -> string {
	if (length(stmts) == 0) 
		""
	else if (length(stmts) == 1)
		state2s(stmts[0])
	else
		state2s(stmts[0]) + ", " + stmts2s(tail(stmts))
}

declarations2s (decls : Declarations) {
	switch (decls : Declarations) {
		Declarations(x): {
			"Declarations(" + decls2s(x) + ")";
		}
	}
}

decls2s (stmts : [VarDecl]) -> string {
	if (length(stmts) == 0) 
		""
	else if (length(stmts) == 1)
		decl2s(stmts[0])
	else
		decl2s(stmts[0]) + ", " + decls2s(tail(stmts))
}

decl2s (d : VarDecl) -> string {
	switch (d : VarDecl) {
		VarDecl(id, type): {
			"VarDecl(" + id2s(id) + ", " + type2s(type) + ")"
		}
	}
}

state2s (s : Statement) -> string {
	switch (s : Statement) {
		VarAssign(id, expr): {
			"Assign(" + id2s(id) + ", " + expr2s(expr) + ")"
		}
		Test(e): {
			"Test(" + expr2s(e) + ")"
		}
	}
}

type2s (type : Type) -> string {
	switch (type : Type) {
		Type(val): {
			"Type(" + val + ")"
		}
	}
}

id2s (id : Identifier) -> string {
	switch (id : Identifier) {
		Identifier(val): {
			"Id(" + val + ")"
		}
	}
}

expr2s (e : ArExpr) -> string {
	switch (e : ArExpr) {
		ArSum(lhs, rhs): {
			"ArSum(" + expr2s(lhs) + ", " + expr2s(rhs) + ")";
		};
		ArMult(lhs, rhs): {
			"ArMult(" + expr2s(lhs) + ", " + expr2s(rhs) + ")";
		};
		ArSub(lhs, rhs): {
			"ArSub(" + expr2s(lhs) + ", " + expr2s(rhs) + ")";
		};
		ArDiv(lhs, rhs): {
			"ArDiv(" + expr2s(lhs) + ", " + expr2s(rhs) + ")";
		};
		ArMod(lhs, rhs): {
			"ArMod(" + expr2s(lhs) + ", " + expr2s(rhs) + ")";
		};
		ArInt(x): { i2s(x) };
		ArrInt(arr): { "UNSUPPORTED" };
		Identifier(id) : { id2s(e) }
	}
}


s2statement(str : string) -> Statement {
	e_gr = "#include education/nsu_translation-and-compilation-methods/NeMo_compiler/program.lingo";
	parsic(
		compilePegGrammar(e_gr), 
		str,
		defaultPegActions
		//SemanticActions(setTree(defaultPegActions.t, "createArInt", \s -> VarAssign(s[0])))
	)
}

s2block(str : string) -> Block {
	e_gr = "#include education/nsu_translation-and-compilation-methods/NeMo_compiler/program.lingo";
	parsic(
		compilePegGrammar(e_gr), 
		str,
		defaultPegActions
		//SemanticActions(setTree(defaultPegActions.t, "createArInt", \s -> VarAssign(s[0])))
	)
}


main() -> int {
	s = "
	VAR x: INT;
	VAR y: INT; 
	{ 
		x := (( (4 - 5 ) * ( 18 + 3)) + ((eee % 2) / 5));	
		y := [1, 2, 3];
		y := [];
		(x * 5)?;
		{
			{x := 4;} U {x := 3;}
		}

		{ x := 145; }*
	}"

	// println(matchLingo("#include education/nsu_translation-and-compilation-methods/NeMo_compiler/program.lingo", s));

	ar = s2block(s);

	println("Raw AST:");
	println(ar);

	//println("AST: " + block2s(ar));

	0;
}


statementToVM (s : Statement, label : int, next : int) -> string {
	switch (s : Statement) {
		VarAssign(id, expr): {
			i2s(label) + ": " + id2s(id) + " := " + expr2s(expr) + " goto {" + i2s(next) + "}"
		}
		Test(e): {
			i2s(label) + ": if(" + expr2s(e) + ") then {" + i2s(next) + "} else {}" 
		}
	}
}

